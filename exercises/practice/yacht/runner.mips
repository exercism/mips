#
# Test score with some examples
#
# s0 - num of tests left to run
# s1 - address of category
# s2 - address of dice array
# s3 - address of expected output word
# s4 - actual output word
# s5 - expected output word

.data

# number of test cases
n:  .word 29

# input values (word sized ints)
category:  .word
        11 # yacht,
        11 # yacht,
        1 # ones,
        1 # ones,
        1 # ones,
        2 # twos,
        4 # fours,
        3 # threes,
        5 # fives,
        5 # fives,
        6 # sixes,
        9 # full house,
        9 # full house,
        9 # full house,
        9 # full house,
        9 # full house,
        10 # four of a kind,
        10 # four of a kind,
        10 # four of a kind,
        7 # little straight,
        8 # big straight,
        7 # little straight,
        7 # little straight,
        7 # little straight,
        8 # big straight,
        7 # little straight,
        8 # big straight,
        0 # choice,
        0 # choice
dice:  .word
        5, 5, 5, 5, 5,
        1, 3, 3, 2, 5,
        1, 1, 1, 3, 5,
        3, 1, 1, 5, 1,
        4, 3, 6, 5, 5,
        2, 3, 4, 5, 6,
        1, 4, 1, 4, 1,
        3, 3, 3, 3, 3,
        3, 3, 3, 3, 3,
        1, 5, 3, 5, 3,
        2, 3, 4, 5, 6,
        2, 2, 4, 4, 4,
        5, 3, 3, 5, 3,
        2, 2, 4, 4, 5,
        1, 4, 4, 4, 4,
        2, 2, 2, 2, 2,
        6, 6, 4, 6, 6,
        3, 3, 3, 3, 3,
        3, 3, 3, 5, 5,
        3, 5, 4, 1, 2,
        1, 2, 3, 4, 5,
        1, 1, 2, 3, 4,
        1, 2, 3, 4, 6,
        1, 1, 3, 4, 5,
        4, 6, 2, 5, 3,
        6, 5, 4, 3, 2,
        6, 5, 4, 3, 1,
        3, 3, 5, 6, 6,
        2, 2, 2, 2, 2

outs:  .word
        50,
        0,
        3,
        3,
        0,
        2,
        8,
        15,
        0,
        10,
        6,
        16,
        19,
        0,
        0,
        0,
        24,
        12,
        0,
        30,
        0,
        0,
        0,
        0,
        30,
        0,
        0,
        23,
        10


failmsg: .asciiz "failed for test inputs: "
expectedmsg: .asciiz ". expected "
tobemsg: .asciiz " to be "
okmsg: .asciiz "all tests passed"
prefix: .asciiz "["
comma: .asciiz ", "
suffix: .asciiz "]"


.text

runner:
        lw      $s0, n
        la      $s1, category
        la      $s2, dice
        la      $s3, outs

run_test:
        lw      $a0, 0($s1)             # read category from memory
        move    $a1, $s2                # move address of dice to a1
        jal     score                   # call subroutine under test
        move    $s4, $v0                # move return value in v0 to s4
        lw      $s5, 0($s3)             # read expected output from memory
        bne     $s4, $s5, exit_fail     # if expected doesn't match actual, jump to fail

        addi    $s1, $s1, 4             # address of next category
        addi    $s2, $s2, 20            # address of next 5 dice
        addi    $s3, $s3, 4             # address of next expected result
        sub     $s0, $s0, 1             # decrement num of tests left to run
        bnez    $s0, run_test           # if more than zero tests to run, jump to run_test

exit_ok:
        la      $a0, okmsg              # put address of okmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        li      $v0, 10                 # 10 is exit with zero status (clean exit)
        syscall

exit_fail:
        la      $a0, failmsg            # put address of failmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        lw      $a0, 0($s1)             # print category that failed on
        li      $v0, 1                  # 1 is print integer
        syscall

        la      $a0, comma              # put address of comma into a0
        li      $v0, 4                  # 4 is print string
        syscall

        move    $a0, $s2                # load dice array address
        li      $a1, 5                  # array size
        jal     print_array

        la      $a0, expectedmsg
        li      $v0, 4
        syscall

        move    $a0, $s4                # print actual that failed on
        li      $v0, 1                  # 1 is print integer
        syscall

        la      $a0, tobemsg
        li      $v0, 4
        syscall

        move    $a0, $s5                # print expected value that failed on
        li      $v0, 1                  # 1 is print integer
        syscall

        li      $a0, 1                  # set error code to 1
        li      $v0, 17                 # 17 is exit with error
        syscall


print_array:
                                        # print array with address $a0, word count $a1
                                        # local variable $t0 points to current element
                                        # local variable $t1 points to end of array

        move    $t0, $a0                # first element of array
        sll     $t1, $a1, 2             # length of array, in bytes
        add     $t1, $a0, $t1           # pointer to end of array

        la      $a0, prefix             # print prefix
        li      $v0, 4
        syscall

        beq     $t0, $t1, output_suffix # jump ahead if array is empty
        j       output_element          # first element is not preceeded by comma

output_comma:
        la      $a0, comma
        li      $v0, 4
        syscall

output_element:
        lw      $a0, 0($t0)             # load element value
        addi    $t0, $t0, 4             # increment pointer
        li      $v0, 1                  # 1 -> "print integer"
        syscall

        bne     $t0, $t1, output_comma  # repeat until we reach end of array

output_suffix:
        la      $a0, suffix
        li      $v0, 4
        syscall

        jr      $ra

# # Include your implementation here if you wish to run this from the MARS GUI.
# .include "impl.mips"
