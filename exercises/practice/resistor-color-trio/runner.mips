#
# Test label with some examples
#
# a0 - first input string, for callee
# a1 - second input string, for callee
# a2 - third input string, for callee
# a3 - pointer to output string, for callee

# s0 - num of tests left to run
# s1 - address of first input string
# s2 - address of second input string
# s3 - address of third input string
# s4 - address of expected output string
# s5 - copy of output location

.eqv BUFFER_SIZE 40

.data

# number of test cases
n:  .word 14

# input values (null terminated)
first:  .asciiz
        "orange",
        "blue",
        "red",
        "green",
        "yellow",
        "blue",
        "black",
        "white",
        "black",
        "blue",
        "orange",
        "orange",
        "white",
        "white"
second:  .asciiz
        "orange",
        "grey",
        "black",
        "brown",
        "violet",
        "violet",
        "black",
        "white",
        "grey",
        "green",
        "orange",
        "orange",
        "white",
        "white"
third:  .asciiz
        "black",
        "brown",
        "red",
        "orange",
        "yellow",
        "blue",
        "black",
        "white",
        "black",
        "yellow",
        "red",
        "green",
        "violet",
        "grey"

# expected output values (null terminated)
outs:  .asciiz
        "33 ohms",
        "680 ohms",
        "2 kiloohms",
        "51 kiloohms",
        "470 kiloohms",
        "67 megaohms",
        "0 ohms",
        "99 gigaohms",
        "8 ohms",
        "650 kiloohms",
        "3.3 kiloohms",
        "3.3 megaohms",
        "990 megaohms",
        "9.9 gigaohms"

failmsg: .asciiz "failed for test input: "
expectedmsg: .asciiz ". expected "
tobemsg: .asciiz " to be "
okmsg: .asciiz "all tests passed"
comma: .asciiz ", "


.text

runner:
        lw      $s0, n
        la      $s1, first
        la      $s2, second
        la      $s3, third
        la      $s4, outs

        li      $v0, 9                  # code for allocating heap memory
        li      $a0, BUFFER_SIZE        # specify length of longest expected output
        syscall
        move    $s5, $v0                # location of allocated memory is where callee writes result

run_test:
        jal     clear_output            # zero out output location
        move    $a0, $s1                # load first input string into a0
        move    $a1, $s2                # load second input string into a0
        move    $a2, $s3                # load third input string into a0
        move    $a3, $s5                # load destination address into a3
        jal     label                   # call subroutine under test
        move    $a3, $s5
        move    $s6, $s5                # take copy of output value
        move    $s7, $s4

scan:
        lb      $t0, 0($s4)             # load one byte of the expectation
        lb      $t1, 0($a3)             # load one byte of the actual
        bne     $t0, $t1, exit_fail     # if the two differ, the test has failed
        addi    $s4, $s4, 1             # point to next expectation byte
        addi    $a3, $a3, 1             # point to next actual byte
        bne     $t0, $zero, scan        # if one char (and therefore the other) was not null, loop

first_scan:
        lb      $t0, 0($s1)
        addi    $s1, $s1, 1
        bne     $t0, $zero, first_scan

second_scan:
        lb      $t0, 0($s2)
        addi    $s2, $s2, 1
        bne     $t0, $zero, second_scan

third_scan:
        lb      $t0, 0($s3)
        addi    $s3, $s3, 1
        bne     $t0, $zero, third_scan

done_scan:
        sub     $s0, $s0, 1             # decrement num of tests left to run
        bgt     $s0, $zero, run_test    # if more than zero tests to run, jump to run_test

exit_ok:
        la      $a0, okmsg              # put address of okmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        li      $v0, 10                 # 10 is exit with zero status (clean exit)
        syscall

exit_fail:
        la      $a0, failmsg            # put address of failmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        move    $a0, $s1                # print first input that failed on
        li      $v0, 4
        syscall

        la      $a0, comma              # put address of comma into a0
        li      $v0, 4                  # 4 is print string
        syscall

        move    $a0, $s2                # print second input that failed on
        li      $v0, 4
        syscall

        la      $a0, comma              # put address of comma into a0
        li      $v0, 4                  # 4 is print string
        syscall

        move    $a0, $s3                # print third input that failed on
        li      $v0, 4
        syscall

        la      $a0, expectedmsg
        li      $v0, 4
        syscall

        move    $a0, $s6                # print actual that failed on
        li      $v0, 4
        syscall

        la      $a0, tobemsg
        li      $v0, 4
        syscall

        move    $a0, $s7                # print expected value that failed on
        li      $v0, 4
        syscall

        li      $a0, 1                  # set error code to 1
        li      $v0, 17                 # 17 is exit with error
        syscall


clear_output:
                                        # zero out output by storing zeros
        addi    $t0, $s5, BUFFER_SIZE   # pointer to end of output buffer

clear:
        subi    $t0, $t0, 4             # decrement pointer
        sw      $zero, 0($t0)           # store a 0 word
        bne     $t0, $s5, clear         # repeat util we have reached the start of the buffer
        jr      $ra

# # Include your implementation here if you wish to run this from the MARS GUI.
# .include "impl.mips"
